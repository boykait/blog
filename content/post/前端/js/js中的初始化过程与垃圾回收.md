---
title: js中的初始化过程与垃圾回收
date: 2019-04-14
categories:
 - js
tags:
 - js	
---

#### js初始化执行过程
&emsp;&emsp; 假使从服务器端请求到的js文件内容如下：

```javascript
test();
console.log('var a: ' + a);
var a = 1;
test();
function test(){
  console.log('function test a: ' + a);
}

// 结果
fuction test a: undefined
var a: undefined
function test a: 1

```
&emsp;&emsp;上述代码写的不规范，但还好没错得让浏览器报什么大错，不过如果刚接触js不久的话，还是会有些迷惑，变量a和方法test都是在定义之前使用，此时都是不存在的，应该会报error这样的错误啊?！事实上，在浏览器端顺利将js文件从服务器端请求回来之后，浏览器js解析器需要对js文件进行解析执行，我们称执行过程为执行期那么在执行js文件之前，js解析器会先对文件进行预编译，对代码进行一些调整，预编译会将变量的定义提升至对应作用域的顶部，但对变量而言，仅仅是定义，不会进行初始化赋值：

```javascript
function test(){
  console.log('function test a: ' + a);
}
var a;
test();
console.log('var a: ' + a);
a = 1;
test();
```
&emsp;&emsp;我们还需要知道词法环境(LexicalEnviroment)，在预处理阶段，先创建一个全局的词法环境对象，接下来会对js文件进行扫描，在这个阶段，预编译会遵循下面规范：
```
1. 分会分两步将先扫描函数，再扫描变量；
2. 函数和变量申明的命名存在冲突，以函数的定义为准，申明方式函数优先级大于函数表达式定义式申明的函数（命名冲突以前者为准），函数的优先级是高于变量的。相同优先级以后面的为准，不同优先级以级别高的为准；
3. 变量和表达式申明函数不会初始化，普通函数声明会初始化为所指向的函数引用地址。
```

知道了js预编译的规范，就不难知道下面js代码段的执行结果了：

```javascript
console.log('var a: ' + a);
var a = 'a';
var b = 'b';
console.log('var b: ' + b);
console.log(test);
function test(){
    console.log('function test');
}
var test = 'test';
console.log(test1);
var test1 = function() {
    console.log('function test1');
}

// 结果
VM116:1 var a: a
VM116:4 var b: b
VM116:6 ? test(){
    console.log('function test');
}
VM116:12 undefined
```

js代码中的变量和函数在词法环境对象中初始化如下：

```javascript
LexicalEnviroment {
  a: undefined,
  b: undefined,
  test: 指向test函数的引用,
  test1: undefined,
}
```

在代码段执行结束后，对应的词法环境对象将变为：
```javascript
LexicalEnviroment {
  a: 'a',
  b: 'b',
  test: 指向test函数的引用,
  test1: 指向test1函数的引用,
}
```

#### 垃圾回收机制
&emsp;&emsp;js作为一种高级语言，有对内存自动的分配、回收的管理机制，虽然说不用像c/c++对内存过分关注，但适当的了解js的垃圾回收对比如内存泄漏、优化等能有一定的认识。
##### 引用计数法
&emsp;&emsp;引用计数法较简单，由于引用类型变量的具体数据是存在堆中，增加一个对该数据对象的引用指向，那么，该对象的引用数加一，去掉一个指向该数据对象的引用对应就减一，当对象的引用数等于0，就认为该对象可以被回收了，在回收器下次运行时就可以将其回收，早期的IE6\7使用的引用计数法，但会存在对象循环相互引用问题导致内存泄漏。

##### 标记-清除法
&emsp;&emsp;标记-清除法是12年后主流浏览器所使用到的垃圾回收方法（当然现在部分浏览器采用了更高级的回收策略，比如分代回收），一般情况下，在内存被耗尽或即将耗尽的情况下，将触发垃圾回收线程工作，标记-清除法用“对象是否具有可达性”来表明这个对象是否需要被回收，主要分为标记和回收两个步骤，个人理解：首先，这个方法假定设置一个根节点（理解为当期执行上下文对象），然后由根节点开始依次节点所引用的对象并作好标记，这样就区分找到所有可达和不可达的对象，然后再遍历所有堆中对象将不具可达性的节点的空间进行回收。
&emsp;&emsp;标记-清除法能够解决循环依赖的问题，但还是存在一些缺陷：
```
1.效率相对不高，标记清除阶段，程序会进入等待状态，所以可能会出现卡顿现象。
2.因为释放对象的空间可能并不连续，所以标记-清除法容易产生碎小空间，在下一次需要分配较大对象存储空间时可能会因为找不到合适的空间而提前触发新一轮的垃圾回收。
```
##### 标记-整理法
&emsp;&emsp;标记-清除法的第二个缺点可以通过标记-整理法来解决，简单理解，标记-整理法在垃圾回收结束后将存活的对象往分配存储的一端靠齐，这样就能腾出一大块完整的空间进行内存分配。

##### v8引擎分代回收
&emsp;&emsp;chrome v8引擎采用的分代垃圾回收：将内存垃圾分为新生代和老年代，整体上老年代所分配的空间是远大于新生代的空间，默认情况下，32位系统新生代内存大小为16MB，老生代内存大小为700MB，64位系统则倍之。
新生代平均分成两块相等的内存空间，叫做semispace，每块内存大小8MB（32位）或16MB（64位），v8针对这两代的垃圾实行不同的回收策略：   

- 新生代：    
&emsp;&emsp;新生代垃圾回收方法主要将新生代内存划为From空间和To空间，每次只利用一块，当From空间进行垃圾回收后，将该空间剩余的存活对象复制到To空间，然后交换两者的角色，反复交替执行，新生代对象的特点就是生命周期短，如果新生代对象经过多代垃圾回收仍然存活，就要按一定策略将其迁移到老年代。

- 老年代    
&emsp;&emsp;老年代空间主要存放新生代晋级的对象以及全局对象，早期是采用标记-清除法，后用标记-整理法。


