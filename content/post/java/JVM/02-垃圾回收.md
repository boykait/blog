---
title: 垃圾回收
date: 2019-09-22
categories:
 - JVM
 - java
tags:
 - JVM
 - 垃圾回收
---

#### 1. 什么是JVM内存垃圾    
&emsp;&emsp;学习类C语言需要对内存的分配和回收都似乎必须得非常的小心翼翼，应为稍不注意就可能是一波内存泄漏问题，java中就有垃圾回收机制帮我们完成不用资源的回收工作。

#### 2. 如何判断垃圾对象     
&emsp;&emsp;想要回收垃圾，那我们需要知道对象处于什么状态才可以当做垃圾被回收，主要有两种：    
```
1. 引用计数法（无法解决循环依赖问题） 
2. 可达性分析（主要方法）
```
&emsp;&emsp;可达性分析是通过GC Roots向下搜索并形成引用链，当对象不在任何一条引用链上时，则可以判定该对象是不可用的。 JVM的GC Roots主要包含如下几种：        
```
1. 虚拟机栈局部变量表中所引用的对象；    
2. 方法区中类静态属性实体的引用对象；(Java7)    
3. 方法区常量引用对象；(Java7)    
4. 本地方法栈中JNI的引用对象    
```      
&emsp;&emsp;垃圾标记过程：
![对象垃圾可达性分析和垃圾标记](/images/190929-jvm_gc_2.png)    

#### 3. 内存划分与演进    
&emsp;&emsp;直接看java7及之前同java8的对比，其实变动较大的就是去永久代操作。

![内存划分和演进对比](/images/190927-jvm_gc_1.png)

#### 4. 内存分配和回收

&emsp;&emsp;堆空间的内存分配和回收：

1.初始状态下，当我们在new申请一块内存优先选择在Eden区进行，随着程序的运行，需要分配更多的内存空间，Eden区域将会耗尽，这个时候我们进行一次Minor GC，将存活的对象复制到Survivor1区并清空Eden区，存活对象年龄+1；     
2. Eden重新根据程序的运行状态按需分配空间，又一次不够用，就会再次触发Minor； GC，将Eden区和Survivor2区的存活对象转入Survivor2区，所有存活对象年龄+1;       
`注:在执行Minor GC过程中，如果发现对象的年龄足够大了，就会将其移动到老年代Renured区。`     
3. 晋升到老年区的对象越来越多，同样会出现空间不足的情况，便会触发Major GC；          
`老年代的晋升默认年龄为15`